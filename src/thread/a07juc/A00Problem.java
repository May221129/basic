package thread.a07juc;

/**
 * 1.ConcurrentHashMap怎么分段的？
 * 2.Collections为什么要将集合的get方法也用synchronized修饰？
 * 	答：
 * 		如果get方法不用synchronized修饰：集合中有3个元素，t1.get(2)，t2.remove(2),
 * 		因为t2执行remove方法，拿到了该容器那把唯一的锁，此时其他线程就不能在操作该容器被synchronized修饰的任何方法了，
 * 		但是，get因为没有加锁，所以t1线程可以同时执行该容器的get方法。下标为2的元素是该容器的最后一个元素，
 * 		但t1在获取但还没获取到的时候，t2删除了该元素，此时就会报错。
 * 3.for循环是非原子性操作，为什么？想让这个非原子操作是线程安全的，最简单粗暴的方法是什么？
 * 	答：见代码中的探究3.1 和 3.2
 * 		想让这个非原子操作是线程安全的，最简单粗暴的方法是用synchronized包起来。
 * 4.锁的范围（大致，并不精准）：
 * 		互斥锁/悲观锁，串行：synchronized强度最大的锁。
 * 		读写锁/乐观锁：允许同时读，但写时只能有一个线程在写。
 * 		CompareAndSwap：并行，没有锁。依靠“内存值 V、预估值 A、更新值 B”确保线程安全。
 * 5.解决多线程的线程安全问题的三种方法：①同步代码块； ②同步方法； ③同步锁Lock。
 */
public class A00Problem {
	private void mian() {
		for(int i = 0; i < 10; i++){//探究3.1 ①声明i，并为i赋上初始值； ②判断i<10是否成立； 成立则执行循环体的逻辑。这里多个步骤，所以是非原子性操作。
			//......3.2 往后的每一步，都是：判断i<10是否成立（原子性操作），成立就执行循环体（可能也是原子性操作）。两个原子性操作加一起就是非原子性操作。
		}
	}
}
