package jdbc.test;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.sql.Blob;

//一、获得数据库自动生成的主键

//二、在数据表中插入 大对象 Blob

//三、读取Blob

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.Statement;
import org.junit.Test;

public class TestJDBC {
	
	
	/**
	 * 读取Blob数据：
	 * 1、使用getBlob()方法读取到Blob对象；
	 * 2、调用Blob的getBinaryStream()方法得到输入流，在使用IO输入输出流操作即可；
	 */
	@Test
	public void tsetQueryBlob(){
		Connection connection = null;
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			connection = jdbc.jdbctools.JDBCTools.getConnection();
			
			String sql = "SELECT id,name,birthday,email,picture FROM customers WHERE id = 20";
			
			ps = connection.prepareStatement(sql);
			
			rs = ps.executeQuery();
			
			if(rs.next()){
				int id = rs.getInt(1);
				String name = rs.getString(2);
				Date birthday = rs.getDate(3); 
				String email = rs.getString(4);
				System.out.println(id + "," + name + "," + birthday + "," + email);
				Blob picture = rs.getBlob(5);
				
				InputStream is = picture.getBinaryStream();
				OutputStream os = new FileOutputStream("C:\\Users\\Administrator\\Desktop\\壁纸1.jpg");
				
				byte[] buffer = new byte[1024];
				int len = 0;
				while((len = is.read(buffer)) != -1){
					os.write(buffer, 0, len);
				}
				os.close();
				is.close();
			}
		}catch(Exception e){
			e.printStackTrace();
		}finally{
			jdbc.jdbctools.JDBCTools.release(rs, ps, connection);
		}
	}
	
	/**
	 * 插入Blob
	 * 
	 * 在数据表中插入 大对象Blob类型的数据，必须使用PreparedStatement，
	 * 因为Blob类型的数据是无法使用字符串进行拼接的。
	 * 
	 * 怎么用：setBlob(int parameterIndex, InputStream inputStream)
	 * 
	 * 缺点：在数据库中存放大对象，是会拉低数据库的整体性能的，
	 * 所以一般情况不在数据库中存放大对象，如果有需要，也是存放大对象的地址值。
	 */
	@Test
	public void testInsertBlob(){
		Connection connection = null;
		PreparedStatement ps = null;
		try {
			connection = jdbc.jdbctools.JDBCTools.getConnection();
			
			String sql = "INSERT customers(name,birthday,email,picture) VALUES(?,?,?,?)";
			
			ps = connection.prepareStatement(sql);
			
//			为占位符赋值：
			ps.setString(1, "傻逼");
			ps.setDate(2, new Date(System.currentTimeMillis()));//获得long型的当前时间，那如果要指定时间呢？
			ps.setString(3, "123@qq.com");
			
			InputStream is = new FileInputStream("Q:\\mylife\\壁纸\\言叶之庭截图\\壁纸1.jpg");
			ps.setBlob(4, is);
			
//			执行更新操作：
			ps.executeUpdate();
		}catch(Exception e){
			e.printStackTrace();
		}finally{
			jdbc.jdbctools.JDBCTools.release(null, ps, connection);
		}
	}
	
	/**
	 * 获得数据库自动生成的主键
	 * 
	 * 怎么用：通过PraparedStatement对象的getGeneratedKeys()方法，获取包含了新生成的主键的ResultSet对象
	 * 
	 * 结果：在ResultSet中只有一列 GENERATED_KEY，用于存放最新生成的主键值。
	 */	
	@Test
	public void testGetKeyValue(){
		Connection connection = null;
		PreparedStatement ps = null;
		try {
			connection = jdbc.jdbctools.JDBCTools.getConnection();
			
			String sql = "INSERT customers(name,birthday,email) VALUES(?,?,?)";
			
//			使用重载的prepareStatement(String sql, int autoGeneratedKeys)方法，
//			来生成PreparedStatement对象：
//			ps = connection.prepareStatement(sql);
			ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			
//			为占位符赋值：
			ps.setString(1, "王十");
			ps.setDate(2, new Date(System.currentTimeMillis()));//获得long型的当前时间，那如果要指定时间呢？
			ps.setString(3, "123@qq.com");
			
//			执行更新操作：
			ps.executeUpdate();
			
//			通过PraparedStatement对象的getGeneratedKeys()方法，获取包含了新生成的主键的ResultSet对象
//			在ResultSet中只有一列 GENERATED_KEY，用于存放最新生成的主键值。
			ResultSet rs = ps.getGeneratedKeys();
			if(rs.next()){
				System.out.println(rs.getObject(1));
			}
			
//			查看主键值是几，
			ResultSetMetaData rsmd = rs.getMetaData();
			for(int i = 0; i < rsmd.getColumnCount(); i++){
				System.out.println(rsmd.getColumnName(i + 1));
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally{
			jdbc.jdbctools.JDBCTools.release(null, ps, connection);
		}
	}
}
