MVCC多版本并发控制（MVCC,Multiversion Currency Control）:
	1:解决点: 在无锁的情况下能解决, 脏读, 不可重复读, 幻读
	2:MVCC的实现:
		2.1: 表的每行都有两列隐藏的字段。createVersion  和 deleteVersion
		在各个事务操作该行的时候，这两行记录就会进行记录下该事务的id
	
		2.2：每开启一个事务(begin trancation)，那么系统版本号便会自增1， 该系统版本号就是该事务的事务id
		
		2.3：那么createVersion和deleteVersion会在什么情况下做怎么样的记录呢？
			分为insert update delete select 来讨论
			(注意insert delete update会动这两列数据的时候, 并非提交事务的时候)
			2.3.1： insert 操作,就会在该新增的行的createVersion上记录下当前事务id
				deleteVersion为空。
		
			2.3.2：delete操作，就会在该行的deleteVersion记录下当前事务id
				createVersion不会动。
		
			2.3.3： update操作，在事务未提交期间，会复制新增一行，且该新行的createVersion
				为当前事务id， deleteVersion为空。  旧数据行的createVersion不变， deleteVersion为当前事务id。
		
			2.3.4 select操作，都不动
		
		2.4：(该点讲的并不完全对， 第五点将进行补充)
			Innodb在查询的时候会确保该行是否符合以下两个条件，如果这两个条件不符合既不返回。(注意：这个查询实际上值得是快照读,也叫做一次性读)
			2.4.1 InnoDB只查找版本早于当前事务版本的数据行（也就是数据行的版本必须小于等于事务的版本），
				这确保当前事务读取的行都是事务之前已经存在的，或者是由当前事务创建或修改的行
		
			2.4.2  行的删除操作的版本一定是为空(未定义)的或者大于当前事务的版本号。
				确定了当前事务开始之前，行没有被删除(非真正删除,只是事务未提交前的删除)。
				为什么删除的时候要确保，当前行的版本号要大于该事务的版本号呢？ 
					因为小于的话就说明该行数据是在该事务之前就被其他事务删除了，等于的话就说明该事务已经删了它，
					只有大于才说明该行数据是在该事务之后被其他事务搞上了。
		
			注意：2.4.1 ，2.4.2都是为了保证当前事务读到的数据是在该事务之前就存在的。
		
		2.5：对于第四点中， “用当前事务id去比较每行后面版本号” 这样的说法是错误的。
			2.5.1 试想：A事务在B事务之前发生，但是A事务还没提交，那么按照MVCC既B事务能读到未提交A事务所操作的数据，这并不行。
			2.5.2 正确的是：InnoDB每个事务在开始的时候，会将当前系统中的活跃事务创建一个副本(readView), 
				然后在一次性读(也就是第2.4说的读)的时候会将readview中最早的一个事务id与数据行中的版本号作比较，这样就确保了B事务能读到的事务都是已经提交的。
			2.5.3 这里还有一个注意点：就是当前事务自身的变更还是应该可见的。
				猜测其做法:拿着当前事务的版本号(id1)和readView中最小的版本号(id2),一起去做对比.  筛选条件(value=id1 || value < id2)
		
		2.6：场景： A  B  C三个事务依次开启。  B事务比A事务先提交。 那么A 能读到B事务提交的内容吗？
			这里分各个隔离级来讲：
			Read Uncommitted  	不适用于MVCC
			Read Committed     	不完全适用MVCC，在该隔离级下A事务能看到B事务提交的内容。这种隔离级是做不了重复读的。
			RepeatAble Read 	完全适用于MVCC, A是读不到B的提交的。
			Seriable 			不适用MVCC， 都是加锁的。