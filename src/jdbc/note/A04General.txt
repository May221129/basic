Mysql结构图(了解即可)
	1 Connectors指的是不同语言中与SQL的交互
	2 Management Serveices & Utilities： 系统管理和控制工具
	3 Connection Pool: 连接池。
		管理缓冲用户连接，线程处理等需要缓存的需求
	4 SQL Interface: SQL接口。
		接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface
	5 Parser: 解析器。
		SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本。
			主要功能：
			a . 将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的 
			b.  如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的
	6 Optimizer: 查询优化器。
		SQL语句在查询之前会使用查询优化器对查询进行优化。他使用的是“选取-投影-联接”策略进行查询。
		用一个例子就可以理解： select uid,name from user where gender = 1;
		这个select 查询先根据where 语句进行选取，而不是先将表全部查询出来以后再进行gender过滤
		这个select查询先根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤
		将这两个查询条件联接起来生成最终查询结果
	7 Cache和Buffer： 查询缓存。
		如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。
		这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等
	8 Engine ：存储引擎。
		存储引擎是MySql中具体的与文件打交道的子系统。也是Mysql最具有特色的一个地方。
		Mysql的存储引擎是插件式的。它根据MySql AB公司提供的文件访问层的一个抽象接口来定制一种文件访问机制（这种访问机制就叫存储引擎）
		现在有很多种存储引擎，各个存储引擎的优势各不一样，最常用的MyISAM,InnoDB,BDB
		默认下MySql是使用MyISAM引擎，它查询速度快，有较好的索引优化和数据压缩技术。但是它不支持事务。
		InnoDB支持事务，并且提供行级的锁定，应用也相当广泛。 
		Mysql也支持自己定制存储引擎，甚至一个库中不同的表使用不同的存储引擎，这些都是允许的。



SQL解析:
	顺序由上到下:
		第一步:from: 笛卡尔积
			我对直接用N张表生成笛卡尔积这种说法表示不赞同: 
				做法:先把N张表拿来做笛卡尔积的话, 然后在从这个超大集合中用on和where来剔除不符合条件的行.
				这样做的话不就是N张表都是全表扫描, 而且再生成一张超级大的笛卡尔积表.  然后在这张超大表中做检索. 这些不都是超级慢的!
			从explain的结果中可以看到,是先驱动表全表扫(或者索引扫), 然后去搞另一张表.  没有看见笛卡尔积的感觉.
			在mysql帮助手册上搜索Cartesian product(笛卡尔积), 在inner join处有这样的描述:
				inner join在缺少连接条件的时候,会生成笛卡尔积. 
				我也实验了两张表.数量分别为13 22, 结果为286.   explain的结果是两个都是all.
				以此猜测: 确实不是一开始就搞一个笛卡尔积, 是一步一步来的.  当缺少筛选条件的时候结果显然是笛卡尔积.
		第二步:on:主表保留
		第三步:join(不符合on也添加), where(非聚合, 非select别名)
		第四名:group by  改变对表引用
		第五步:having 只作用分组后
		第六步:select  distinct
		第七步:order by  可使用select别名
		第八步:limit rows offset