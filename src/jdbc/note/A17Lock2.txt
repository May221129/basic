mysql的锁机制相关的问题：

1.锁放程序代码这边，还是数据这边，为什么？
	答：锁要放在共享数据这边，否则：
		系统A和系统B都能够连接同一数据库去访问、操作数据，系统A的代码有锁，
		但是这限制系统B去访问、操作数据，所以这把锁是无效的。
2 存储引擎
	2.1 存储引擎的分类：https://www.cnblogs.com/sunsky303/p/8274586.html
		（1）InnoDB（默认的存储引擎）：事务型的存储引擎，有行级锁定和外键约束。由于锁的粒度更小，
			写操作不会锁定全表，所以在写操作并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是
			绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。
		（2）MyIsam：只支持表锁，不支持事务、行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作
			需要锁定整个表，效率便会低一些。查询速度很快，如果对数据库insert和update的操作比较少的话比较适用。
		==》注意：“MyISAM不支持事务，就需要在service层对事务进行控制。”这句话是错的，
			代码层只是做了开启和提交，底层还是需要数据库的支持（用InnoDB）
		（3）Memory（也叫HEAP）堆内存：使用存在内存中的内容来创建表。每个MEMORY表只实际对应一个
			磁盘文件。MEMORY类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用HASH索
			引。但是一旦服务关闭，表中的数据就会丢失掉。 HEAP表格在你需要使用SELECT表达式来选择和操控数据的时候非常有用。
		（4）Blackhole（黑洞引擎）：
		（5）其他。
	2.2 引擎和锁之间的关系：
		InnoDB：支持表锁、行锁。
		MyISAM：只支持表锁。
3.事务的基本要素、并发问题和数据库的隔离级别：
	4种事务的基本要素：（ACID）atomicity、consistency、isolation、durability、
	4种事务的并发问题：脏读、不可重复读、幻读、更新丢失。
	4种隔离级别：读未提交、读已提交、可重复读、串行化。
	不同的隔离级别分别解决了哪些事务的并发问题：
		读未提交==》无
		读已提交==》脏读；
		可重复读==》脏读+不可重复读+幻读；
		串行化==》脏读+不可重复读+幻读+更新丢失。
3.1 ACID和锁的关系。
3.2 “可重复读”这个隔离级别是如何防止幻读的？
	答：GAP是针对where条件是普通索引才会需要，如“delete from t1 where id = 10、id是非唯一索引”。
	而主键索引和唯一索引都具有数据的唯一性，所以如果已经存在于索引树中的数据，是不能再重复插入了。
	具体见：博客http://hedengcheng.com/?p=771#_Toc374698322 ==》 组合七：id非唯一索引+RR

4.SQL语句如何上锁？（博客有详情：http://hedengcheng.com/?p=771#_Toc374698322）  
	
5.表是如何加读锁或写锁的？
	答：这是MySQL自己确定的时机。如果要做测试，则可通过下面的“6.常使用的和锁相关的语句（1）”所示，为表加读写锁。
	5.1.读阻塞写，怎么办？
		答：mysql对其做了处理，设置了默认的等待的时间等。
		
6.常使用的和锁相关的语句：
	(1)手动增加表锁：lock table 表名1 read/write，表名2 read/write，其他；
	(2)查看所有被打开的表列表(是所有,并非只有当前会话):show open tables; ==》1就是锁了，0就是没上锁
	(3)给当前会话所有锁住表解锁:unlock tables;
	(4)分析表锁的频度,及表锁争用等待情况:show status like 'table%';
	(5)查看当前数据库的事务隔离级别：show variables like 'tx_isolation'
	(6)关闭数据库的自动提交：set autocommit=0;    如果想再开启：set autocommit=1

---------------无锁算法 -> cas -> mvcc -> 快照读/当前读----------------------
7.MySQL什么时候使用CAS？
	答：select时都会用上mvcc，但其底层用的是cas。
	7.1 使用CAS要考虑并发量，为什么？
		答：
	7.2 不是自增，而是改变数字，随机改变数字，这样还适合用cas吗？
		答：
		
8.在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：
	快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析,详见博客：http://hedengcheng.com/?p=771#_Toc374698322)
	当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。
		select * from table where ? lock in share mode;
		select * from table where ? for update;
		insert into table values (…);
		update table set ? where ?;
		delete from table where ?;

9.①读写分离的目的之一是为了提高数据库的效率，解决数据库的读性能瓶颈；②mvcc支持“读写不冲突”。
	提问：①在不考虑数据库的数据备份的情况下，是否有了mvcc就不需要再做读写分离了？
	②mvcc和“数据库的读写分离”的效率对比。

===============================================================
读博客： http://hedengcheng.com/?p=771#_Toc374698322 
1.RDBMS即关系数据库管理系统(Relational Database Management System)
2.在读多写少的OLTP(联机事务处理过程)应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS(关系数据库管理系统)，都支持了MVCC。
3.select * from table where ?; 为什么是快照读？
	答：如果没加锁，快照读是读已经提交了的，就不会出现数据不一致的问题。
4.“快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。” ==》 提问：数据库在同一时刻，某行数据会存在多个版本吗？
5.“当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。” ==》 提问：什么时候是当前读？当前读不是违背了“mvcc支持读写不冲突”吗？
	答：select语句最后加了“for update”或“lock in share mode”时，和update、delete、insert的SQL语句，都是当前读。
	SQL语句中主动去加了锁，或是对数据进行写操作的，都是当前读。普通的读则是在同时又当前读的时候去读快照。
6.“从图中，可以看到，一个Update操作的具体流程。当Update SQL被发给MySQL后，MySQL Server会根据where条件，
	读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。” 
	答：实际意思：MySQL Server根据where条件让InnoDB去检索符合条件的记录，一旦检索到一条，
		就将这记录返回给MySQL Server，MySQLServer收到这条记录后・・・・・・
	注：server 和innodb 分离开    就是模块化  或者 单一原则的体现。
!!! ==> 7.同一时刻下，只能有一个事务在对某一行记录做写操作。如：mvcc的update，对数据执行写操作时会给这行数据加上锁（current read）。
	对“mvcc支持读写不冲突”的猜测：同一行数据可能存在多个版本――当前版本和历史版本，普通的读（select * from tableName where id=1）是快照读，
	读的是历史版本；而当前读，读的是当前版本；所以同时读和写才能不冲突。
	MySQL的默认隔离级别是可重复读，所以当写操作的事务commit后的记录就成了最新版本，update之前的版本就是历史版本。
8.“delete from t1 where id = 10; ==》对id = 10的记录加写锁 (走主键索引)。”
	理解：写都是会加锁的，
9.建表语句：①二级索引存放的是一级索引的主键，如：name是二级索引，id是一级索引，在name的索引树的叶子结点存放的就是对应的一级索引的id。
	提问：为什么要建立二级索引？
	②在使用char数据类型的时候，最好是定长，这样能够增加效率。这增加了什么效率？为什么？
	③唯一索引和非唯一索引的区别。
10.什么能够影响到是进行索引扫描还是全盘扫描。
	答：where后面的条件是否建立了索引。有，则根据索引来查找，没有则进行全盘扫描。
11.①在数据库的隔离级别为“serializable”时，不论读、写都会对整张表上锁，对吗？
		答：对。
	②在数据库的隔离级别为“Read Uncomited”时，是不是读、写都不会对数据进行上锁？
		答：对。
12.数据库的锁是什么？
	答：当数据库使用的是InnoDB存储引擎时，InnoDB的底层数据结构是B+树，当某个字段建立了索引时，锁是用来锁住该字段的索引树的叶子结点的。
		如：id是主键索引，update user set age=10 where id=1;此时的锁就锁住了id字段的索引树中id=1的叶子结点。
13.如果SQL语句的where条件都没有命中索引，查询数据的效率就会很低，对吗？
	答：是的。如：
		select * from user where age = 10.
		age字段没有建立索引。SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。
		因此每条记录，无论是否满足条件，都会被加上X锁。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，
		最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略。同时，优化也违背了2PL的约束。
	推导：我们需要对“常用于检索的字段”建立索引。当然，索引树也不是越多越好。
14.对每个字段都建立索引，可以吗？为什么？
	答：不行。原因：①建立了索引后，在存放数据的时候速度会比较慢。②也会消耗磁盘容量，因为索引树需要在磁盘上建立。
	注：表中的全量数据都存放在聚簇索引的叶子结点。除了这里，就不会另外存放了。
15.主键索引、唯一索引、非唯一索引，这三者的比较：https://www.jianshu.com/p/81305113fc3c
16.“MVCC并发控制降级为Lock-Based CC” ==》 MVCC还可以设置并发控制级别吗？
	答：
	
===============================================================
读博客：mvcc:https://segmentfault.com/a/1190000012650596
1.MVCC的基础：
	1.1 MVCC是什么？
		答：MVCC是多版本的并发控制协议，底层是CAS。它是乐观锁的一种实现方式。
	1.2 MVCC和锁什么关系？
		答：严格来说，没有关系。行锁、表锁等都是存储引擎的行为。1.1种说到的“它是乐观锁的一种实现方式”，是因为MVCC的多版本的并发控制。
	1.3 MVCC和InnoDB有什么关系：InnoDB存储引擎的实现基于MVCC。
	1.4 MVCC最大的好处：读不加锁，读写不冲突。
	1.5 MVCC的读操作的分类：快照读、当前读。
	
2.MVCC并没有简单的使用数据库的行锁，而是使用了行级锁，row_level_lock,而非InnoDB中的innodb_row_lock.
4.修改时Copy出当前版本随意修改，各个事务之间无干扰。 ==》 有点类似容器“CopyOnWriteArrayList/CopyOnWriteArraySet:写入并复制。”
5.保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）==》 cas:原值、比较值、目标值
6.用来和查询每行记录的版本号进行比较。==》不明白什么是“查询每行记录的版本号”
7.更新丢失




