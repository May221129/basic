查mysql手册可以解决非常多问题, 只不过english看得吃力

join类型(联想集合图:两个集合交并):
	左连接: left join  	
	右连接: right join
	内连接: inner join 	交集
	自然连接:natural join,自动对两个表按照同名的列进行内连接,使用自然连接要注意，两个表同名的列不能超过1个。等值连接(不用join, 加个where)不把重复的属性除去；而自然连接要把重复的属性除去。
	等值连接: 跟inner join 一样
	
	只取左圆圈独有: left join    where R.id is null;
	只取右圆圈独有: right join	where L.id is null;
	
	mysql没有outer join
	两圆圈去掉公有部分:	只取左圆圈独有  	union 	只取右圆圈独有
	两个圆圈的所有:		左连接  		union 	右连接
	union自带去重功能.
	

mysql 300w数据  性能就下降了
mysql的瓶颈
	CPU
	IO
	配置，如缓存等   这块的配置包括mysql的配置和服务器的配置


慢查询截取分析步骤:
	分析：
		1:观察,至少跑一天,看看生产环境下的慢sql情况.
		2:开启慢查询日志,设置阈值,比如超过5秒钟的就是慢sql,并将其抓取出来.
		3:explain  +  慢sql分析
		4:如果经过第三步还是没有得到原因, 就show profile
			show profile分析粒度更细
		5:数据库服务器的参数调优.


		
这个文档整理下来之后都要做一遍实验. 有些不明白但是觉得重要的还要明白其原因


搞清楚mysql全局和局部变量

my.ini调优
	http://blog.csdn.net/cenfei78325747/article/details/7861454  调优buffer cache等

force index 强制使用索引的语法还有好多 https://dev.mysql.com/doc/refman/5.6/en/index-hints.html
	包括连表的时候强制使用的索引等等,  应该挺好玩的.


mysql的缓存机制还是不了解.  何时缓存,  缓存多大,  如何命中,  如何失效等等

在测试索引覆盖的时候， 加主键字段到select后面,是不影响的.
但是在测试order by的时候加主键字段又会有影响.  
不知道其他情况下主键存在会产生的影响, 要总结一下并寻找原因.

left join 的优化  
	inner join 和 不用join 用where查询没区别,  不过感觉用where的话 可能可以优化

范式:
	第一范式：列的不可分割性。
		举例：有个字段为“联系方式”，该字段填入的记录由“电话号码+地址”组成。此时，这个“联系方式”字段，是可以分割为“电话号码”字段+“地址”字段的，所以这张表就不符合第一范式。
		如果列设为“联系方式”，存在的问题：
			增：从前端传来2个电话号码和地址，服务器还得对其进行核对、拼接，再和其他内容一起封装成一个实体，插入到数据库中，这个过程就因为数据表的设计不合理，显得复杂而又没有意义。
			删：和查类似。
			改：如果要单独修改电话号码，还得把整个“联系方式”拿出来，截取出电话号码，修改好，然后再放回数据表中。如果是“电话号码”、“地址”两个字段，就直接对电话号码进行修改即可。
			查：1.如果想通过某个电话号码来查找记录，就更麻烦了，需要把所有的“联系方式”都拿出来截取出电话号码，再进行比对。
				2.如果通过ID想查姓名、电话号码，还得找到这条记录后，拿到“联系方式”，截取出电话号码。
	第二范式：在1NF的基础上，消除非主属性对码的部分函数依赖。（完成依赖是可以的，部分依赖说明可能存在数据的冗余，是要消除的。）
		举例：
		符合第二范式的：
			A表：学生表； B表：课程表； C表：选课表（即关系表，由 id、学生id、课程id、分数 组成）
			选课表的码是 学生id和课程id 共同组成的；分数是由“学生id和课程id”共同决定的，（学生id,课程id）-> 分数，即分数完全依赖于（学生id，课程id）。
		不符合第二范式的：
			A表：学生表（id,学号，姓名）； B表：课程表（id，课程名）； C表：选课表（即关系表，由 id、学生id、课程id、分数 组成）
			选课表的码是 学生id和课程id 共同组成的；（学号，课程）-> 姓名，这里的姓名就是部分依赖于码，完全依赖于学号。
		总结：会出现不符合第二范式的场景，一般是在关系表中。因为关系表中的码往往是由两个字段或大于两个地段共同组成的，此时除码之外的非主属性如果完全依赖于码中的某一个字段，就会违背第二范式。
	第三范式：在1NF和2NF的基础上，消除非主属性对码的传递函数依赖。
		传递：3 > 2 , 2 > 1 ,得 3 > 1，这是数学里的传递。
		传递依赖：学生可以找到他的班级，班级可以得到班级地址，所以通过一个学生就能找到他的班级地址。
		举例：
			StudyNo   |   Name   |   Sex   |      Email      |      Phone    |   ClassNo  | ClassAddress
			这里可以通过StudyNo找到ClassNo，可以通过ClassNo找到ClassAddress，所以ClassAddress对StudyNo存在传递性依赖。
			消除传递性依赖：要变为两个表
				表一：StudyNo   |   Name   |   Sex   |     Email     |      Phone  |   ClassNo
				表二：ClassNo  | ClassAddress
				
	注：1. 码是唯一标识一行记录的字段。
		2. 范式并非绝对的。有时应按现在的需求并结合未来可能发生的变化来进行数据表的设计。
		3. 表与表之间的关系，都是两两之间的。
		
		why ==> 为什么有范式：如果没有范式，表结构会很冗长，增、删、改、查都会有存在很多问题，表关系也会复杂，范式就是为了避免这些问题而存在的。
		how ==> 范式怎么用：数据表设计好之后，再对照范式的要求来检查表的设计是否合理，如果没有遵循范式则做改进。而非按照范式来直接设计数据表。

额外的知识点:
	1:小表驱动大表
		驱动表是在使用多表嵌套连接时，会先全表扫描驱动表， 然后将其结果一行一行的
		去匹配被驱动表.  所以， 我们平常基本上是用小表当驱动表, 因为小表的数据量比较
		少， 做全表扫描可以被接受, 当然了 因为是一行一行的去大表做匹配的，所以大表
		的匹配字段肯定是要做索引的, 不然每次匹配大表都相当于全表扫描的话就更惨了.
		但是哪张表先查我是懵逼的
		
	2:比较exist in 的用法以及定义，以及效果 适用场景等
		oracle用hash join 来处理in  而exist是两层嵌套的循环.
		
		
	3:临时表:	
	
	
	4:InnoDB MyISAM 索引的数据结构:http://www.jianshu.com/p/1775b4ff123a
		
	
	5：对于组合索引， where order by group by   
		非得按顺序来才能全部用得上  idx_c1_c2_c3
		where c1  order by c3   那么会用上type是ref   不过会有filesort
		where c1 and c2 order by c3  索引也会用得上也不会有filesort.  这里 order by 可以随意填写 c1 c3  或者c3
		from t order by c1 虽然是all   如果没有where 直接来order by 都有filesort
		where c1 order by c3, c2   有ref  有filesort  因为c3 c2顺序不对
		一定要是有顺序  c1 c2 c3.   一定要从c1开始.
	
	6:个人猜想的索引的实现,  首先B是由比大小而形成的一棵树，那么如果字段是字符怎么办呢，   我觉得是按单个单个的字符来变换成数字集合.  
		就像比较两个字符串的原理一样.  这样就可以比较两个字符串的大小了.
		且组合索引差不多也就是这种转换的扩展(更长点，只不过肯定有界限)
		
		如果有多个字段组成的索引， 那么它们的顺序   c1比完 比c2  c2比完再比c3       跟order by多个值一样.
			当然索引和索引之间插入非索引的where条件是可以, 比如 where t1 = 1 and t4 = 3 order by t2 desc;  t1 t2是组合索引,
			而t4不是索引.  这样t1 和 t2都可以用到组合索引.   不过我觉得order 在order by插入一个其他值的话估计就不行了(没试过).
	
	7：三大表连接方式:
		7.1:Nested Loop Join
			就是嵌套循环.
			要以小表作为驱动表
			连接字段要建立索引
			
		7.2:hash join
			将A表按连接键计算出一个hash表，然后从B表一条条抽取记录，计算hash值，根据hash到A表的hash来匹配符合条件的记录
				就好像我当初为一个集合专门建造一个hashMap的感觉一样,  因为有好多元素会一轮轮流判断是否在那个集合内.
				
		7.3 Sort Merge Join
			好像是先将两张表进行排序, 然后在搞, 具体不知道.
			不过听说hash join是用来替代这个的,  不过hash join可想而知cpu肯定很耗
		
